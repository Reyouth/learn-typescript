(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{424:function(t,r,a){"use strict";a.r(r);var _=a(2),e=Object(_.a)({},(function(){var t=this,r=t._self._c;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"什么是git"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#什么是git"}},[t._v("#")]),t._v(" 什么是Git？")]),t._v(" "),r("p",[t._v("git是目前世界上最先进的分布式版本控制系统。")]),t._v(" "),r("h2",{attrs:{id:"git与svn的最主要区别"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#git与svn的最主要区别"}},[t._v("#")]),t._v(" git与SVN的最主要区别？")]),t._v(" "),r("p",[t._v("SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候用的都是自己的电脑，所以开始工作之前需要从中央服务器那里获取最新的版本，然后开始工作，工作完后，需要把自己所做的工作推送到中央服务器。集中式版本控制系统必须要联网才能工作，如果在局域网中，有足够的宽带，运行速度够快，而在互联网环境下，网速慢通常会导致服务难以进行。")]),t._v(" "),r("p",[t._v("git是分布式版本控制系统，没有中央服务器，每个人的电脑是一个完整的版本库，这样，工作的时候可不需要联网，因为版本都在自己电脑上，即每个人的电脑都有一个完整的版本库，那么如何实现多人协作呢？比如自己在电脑上修改了文件A，别人也修改了文件A，此时，需要把两人之间各自所做的修改推送给对方，就可以互相看到对方所做的修改了。")]),t._v(" "),r("h2",{attrs:{id:"安装"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#安装"}},[t._v("#")]),t._v(" 安装")]),t._v(" "),r("p",[t._v("安装msysGit非常简单，访问msysGit的项目主页"),r("a",{attrs:{href:"http://code.google.com/p/msysgit/",target:"_blank",rel:"noopener noreferrer"}},[t._v("msysgit"),r("OutboundLink")],1),t._v("，下载msysGit on windows")]),t._v(" "),r("p",[t._v("命令行输入git config --list，如果最后两行信息,"),r("code",[t._v("user.name")]),t._v(","),r("code",[t._v("user.email")]),t._v("和你之前输入的相同，则完成了git的基本配置。")]),t._v(" "),r("h2",{attrs:{id:"常用的命令与工作流程"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#常用的命令与工作流程"}},[t._v("#")]),t._v(" 常用的命令与工作流程")]),t._v(" "),r("p",[t._v("Git 的工作就是创建和保存你项目的快照及与之后的快照进行对比。")]),t._v(" "),r("h3",{attrs:{id:"创建新仓库"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#创建新仓库"}},[t._v("#")]),t._v(" 创建新仓库")]),t._v(" "),r("p",[t._v("创建新文件夹，打开，然后执行 "),r("code",[t._v("git init")]),t._v(" 以创建新的 git 仓库")]),t._v(" "),r("h3",{attrs:{id:"检出仓库"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#检出仓库"}},[t._v("#")]),t._v(" 检出仓库")]),t._v(" "),r("p",[t._v("执行如下命令以创建一个本地仓库的克隆版本：\n"),r("code",[t._v("git clone /path/to/repository")])]),t._v(" "),r("p",[t._v("如果是远端服务器上的仓库\n"),r("code",[t._v("git clone username@host:/path/to/repository")])]),t._v(" "),r("h3",{attrs:{id:"理解工作流"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#理解工作流"}},[t._v("#")]),t._v(" 理解工作流")]),t._v(" "),r("p",[t._v("你的本地仓库由 git 维护的三棵“树”组成。第一个是你的 "),r("strong",[t._v("工作目录")]),t._v("，它持有实际文件；第二个是 "),r("strong",[t._v("缓存区（Index）")]),t._v("，它像个缓存区域，临时保存你的改动；最后是 "),r("strong",[t._v("HEAD")]),t._v("，指向你最近一次提交后的结果，如果包括远程仓库，那就是四个流。")]),t._v(" "),r("h3",{attrs:{id:"添加与提交"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#添加与提交"}},[t._v("#")]),t._v(" 添加与提交")]),t._v(" "),r("p",[t._v("使用 "),r("code",[t._v("git add <filename>")]),t._v(" "),r("code",[t._v("git add .")]),t._v(" 把计划的改动添加到缓存区")]),t._v(" "),r("p",[t._v("这是 git 基本工作流程的第一步；使用如下命令以实际提交改动\n"),r("code",[t._v('git commit -m "代码提交信息"')])]),t._v(" "),r("p",[t._v("现在，你的改动已经提交到了 HEAD，但是还没到你的远端仓库")]),t._v(" "),r("p",[t._v("通过使用 "),r("code",[t._v("git push origin master")]),t._v(" 除了"),r("strong",[t._v("master")]),t._v("可以是你想要的任何分支")]),t._v(" "),r("h3",{attrs:{id:"克隆"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#克隆"}},[t._v("#")]),t._v(" 克隆")]),t._v(" "),r("p",[t._v("如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加\n"),r("code",[t._v("git remote add origin <server>")])]),t._v(" "),r("p",[t._v("如此你就能够将你的改动推送到所添加的服务器上去了")]),t._v(" "),r("h2",{attrs:{id:"git分支管理-版本控制以及协同工作"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#git分支管理-版本控制以及协同工作"}},[t._v("#")]),t._v(" Git分支管理：版本控制以及协同工作")]),t._v(" "),r("p",[t._v("分支是用来将特性开发绝缘开来的。在你创建仓库的时候，master 是“默认的”。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作，完成后再将它们合并到主分支上。")]),t._v(" "),r("h3",{attrs:{id:"实例演示"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#实例演示"}},[t._v("#")]),t._v(" 实例演示")]),t._v(" "),r("p",[t._v("创建一个叫做“feature_x”的分支，并切换过去\n"),r("code",[t._v("git checkout -b feature_x")])]),t._v(" "),r("p",[t._v("切换回主分支\n"),r("code",[t._v("git checkout master")])]),t._v(" "),r("p",[t._v("再把新建的分支删掉\n"),r("code",[t._v("git branch -d feature_x")])]),t._v(" "),r("p",[t._v("除非你将分支推送到远端仓库，不然该分支就是 不为他人所见的")]),t._v(" "),r("p",[r("code",[t._v("git push origin <branch>")])]),t._v(" "),r("h3",{attrs:{id:"更新与合并"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#更新与合并"}},[t._v("#")]),t._v(" 更新与合并")]),t._v(" "),r("p",[t._v("要更新你的本地仓库至最新改动 "),r("code",[t._v("git pull")])]),t._v(" "),r("p",[t._v("以在你的工作目录中 获取（fetch） 并 合并（merge） 远端的改动。\n要合并其他分支到你的当前分支（例如 master），执行：\n"),r("code",[t._v("git merge <branch>")])]),t._v(" "),r("p",[t._v("两种情况下，git 都会尝试去自动合并改动。不幸的是，自动合并并非次次都能成功，并可能导致 冲突（conflicts）。 冲突会在控制台标记出，方便我们人肉合并或者修改。\n改完之后，你需要执行如下命令以将它们标记为合并成功：")]),t._v(" "),r("p",[r("code",[t._v("git add <filename>")])]),t._v(" "),r("h2",{attrs:{id:"链接与资源"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#链接与资源"}},[t._v("#")]),t._v(" 链接与资源")]),t._v(" "),r("p",[r("a",{attrs:{href:"http://book.git-scm.com/",target:"_blank",rel:"noopener noreferrer"}},[t._v("Git社区"),r("OutboundLink")],1),t._v(" "),r("a",{attrs:{href:"http://progit.org/book/",target:"_blank",rel:"noopener noreferrer"}},[t._v("专业Git"),r("OutboundLink")],1)])])}),[],!1,null,null,null);r.default=e.exports}}]);