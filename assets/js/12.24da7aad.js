(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{407:function(v,_,t){v.exports=t.p+"assets/img/TCP3.c775376f.jpg"},408:function(v,_,t){v.exports=t.p+"assets/img/TCP4.53e2ed33.jpg"},428:function(v,_,t){"use strict";t.r(_);var e=t(2),o=Object(e.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h3",{attrs:{id:"三次握手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#三次握手"}},[v._v("#")]),v._v(" 三次握手")]),v._v(" "),_("p",[v._v("TCP建立连接的方式叫"),_("strong",[v._v("握手")])]),v._v(" "),_("p",[v._v("建立TCP连接需要三次握手,即通信双方将通过三次TCP报文实现对以上信息的了解，并在此基础上建立一个TCP连接.")]),v._v(" "),_("p",[_("img",{attrs:{src:t(407),alt:""}})]),v._v(" "),_("ol",[_("li",[_("p",[v._v("服务器进程B先创建传输控制模块TCB，并进入LISTEN状态，准备接收客户端请求")])]),v._v(" "),_("li",[_("p",[v._v("客户端进程A首先创建传输控制模块TCB，然后发出请求报文段，此时同步位"),_("code",[v._v("SYN=1")]),v._v(",同时选择一个初始序号"),_("code",[v._v("seq=x")]),v._v(",之后九年如SYN-SENT状态")])]),v._v(" "),_("li",[_("p",[v._v("B收到连接请求报文段后，如果同意连接，则发送确认报文段，此时SYN和ACK都为1，确认号"),_("code",[v._v("ack = x+1")]),v._v("，表示B成功收到A的请求，并为自己选择一个初始序号"),_("code",[v._v("seq=y")]),v._v(",之后也进入了SYN-RCVD状态")])]),v._v(" "),_("li",[_("p",[v._v("A收到B确认后，发出最终确认，确认报文段的ACK为1，确认号"),_("code",[v._v("ack=y+1")]),v._v("，表示A也成功收到B请求，序号"),_("code",[v._v("seq=x+1")]),v._v("，A进入ESTABLISHED状态")])]),v._v(" "),_("li",[_("p",[v._v("B收到A的最后确认后也进入ESTABLISHED状态")])])]),v._v(" "),_("blockquote",[_("p",[v._v("TCP标准规定，ACK报文段可以携带数据也可以不携带，携带即看作已经开始正式传输，则被传输序号被消耗，因为已发送；若不携带则下一次正式开始是序号不增加。")])]),v._v(" "),_("blockquote",[_("p",[v._v("ack带对方序号标注是否接收到，seq记录自己发送/接收的数据序列，ack不等价于ACK 一个是首段标志位只有真假 一个是序号为整数")])]),v._v(" "),_("h3",{attrs:{id:"四次握手"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#四次握手"}},[v._v("#")]),v._v(" 四次握手")]),v._v(" "),_("p",[v._v("在数据结束传输后，通信双方都可以释放连接")]),v._v(" "),_("p",[_("img",{attrs:{src:t(408),alt:""}})]),v._v(" "),_("ol",[_("li",[v._v("A先主动关闭连接，此时需要发送连接释放报文段，对应的是首部终止控制位FIN=1，序号"),_("code",[v._v("seq=u")]),v._v("，其中u为数据传输最后一个数据的的最后一个字节的序号"),_("strong",[v._v("加一")]),v._v("。之后A进入FIN-WAIT-1状态(FIN表示终止，主动关闭)")]),v._v(" "),_("li",[v._v("B接收到连接释放报文段后立即发出确认，ACK=1表示收到，"),_("code",[v._v("ack=u+1")]),v._v("表示收到第u个包后的第u+1个包，"),_("code",[v._v("seq=v")]),v._v(",v也是前面数据传输最后一个数据的最后一个字节的序号"),_("strong",[v._v("加一")]),v._v("。B进入CLOSE-WAIT，并通知高层应用进程关闭。")])]),v._v(" "),_("blockquote",[_("p",[v._v("此时TCP是半关闭状态，因为是A发起的终止，所以肯定A是完成数据传输后才执行，A肯定无数据要发送给B，但是B是接收终止方，B可能存在进程正在执行，所以如果B要发送数据给A，A仍然要接收")])]),v._v(" "),_("ol",[_("li",[v._v("A收到来自B的确认后进入FIN-WAIT-2状态，等待B处理完剩余进程后，发出连接释放报文段")]),v._v(" "),_("li",[v._v("B中的高层应用进程如果没有数据发送，B就可以发送释放TCP连接了。此时B发送释放连接报文段：FIN=1(轮到B主动),")]),v._v(" "),_("li",[v._v("序号"),_("code",[v._v("seq=w")]),v._v("(w是B发送的最后一个字节的序号加一，因为之前B工作A终止发送中B可能还在继续发送)，"),_("code",[v._v("ack=u+1")]),v._v("表示接着第二步，对应A的终止进程.B进入LAST-ACK状态")]),v._v(" "),_("li",[v._v("B收到A的确认后进入CLOSED")]),v._v(" "),_("li",[v._v("A经过两倍MSL（最长报文段寿命），进入CLOSED")])]),v._v(" "),_("blockquote",[_("p",[v._v("，2倍MSL是因为B之前仍然发送A，A需要处理时间，给够时间保证A发送的最后一个ACK能到达B。根据超时重传机制，如果B没有收到最后确认，会重发FIN+ACK,继续询问A是否完成\n另外 两倍报文寿命时间也是确保本次连接的报文彻底消失，而不会污染下一次连接报文请求")])]),v._v(" "),_("p",[_("a",{attrs:{href:"https://xiaolincoding.com/network/3_tcp/tcp_interview.html",target:"_blank",rel:"noopener noreferrer"}},[v._v("图片参考连接"),_("OutboundLink")],1)])])}),[],!1,null,null,null);_.default=o.exports}}]);